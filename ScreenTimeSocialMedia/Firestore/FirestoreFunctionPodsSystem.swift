//
//  FirestoreFunctionPodsSystem.swift
//  ScreenTimeSocialMedia
//
//  Created by Andrew Kuznetsov on 10/5/23.
//

import Foundation
import FirebaseFirestore

extension FirestoreFunctions {
    
    // stores a a Pods instance in firestore
    func createPod(pod: Pods) {
        let docRef = PODS_REF.addDocument(data: [
            "title": pod.title!,
            "podType": pod.podType.rawValue,
            "currentStrikes": 0,
            "totalStrikes": pod.totalStrikes!,
            "goal": pod.goal!,
            "timeframe": pod.timeframe!,
            "started": pod.started!,
            "failedDays": pod.failedDays!,
            "currentDay": pod.currentDay,
            "owner": CURRENT_USER_UID
        ]) { error in
            if let error = error {
                print("createPod(): Error adding pod: \(error)")
                return
            }
        }
        
        let generatedPodID = docRef.documentID // gets podID generated by firestore
        
        // Create a document in Current user's pod collection with the pod id
        CURRENT_USER_PODS_REF.document(generatedPodID).setData([:])
        
        // Add the current user to the list of pod users
        addUserToPod(podID: generatedPodID)
        
        // as soon as user creates pod begin monitoring screentime in the background
        ScreenTimeViewModel().beginMonitoring(pod: pod)
    }
    
    func addUserToPod(podID: String) {
        // save user uid and username in pod instance document
        PODS_REF.document(podID).collection("users").document(CURRENT_USER_UID).setData([
            "username": CURRENT_USER_USERNAME,
            "currentStreak": 0,
            "numStrikes": 0
        ]) { err in
            if let err = err {
                print("addUserToPod(): error adding user to pod: \(err)")
            }
        }
        
        // adds pod instance to CURRENT_USER's doucment
        CURRENT_USER_PODS_REF.document(podID).setData([:])
    }
    
    func removeUserFromPod(podID: String, user: User, completion: @escaping () -> Void) {
        PODS_REF.document(podID).collection("users").getDocuments { (querySnapshot, error) in
            if let error = error {
                print("removeUserFromPod(): Error getting documents: \(error)")
            } else {
                // Count the number of documents
                let documentCount = querySnapshot?.documents.count ?? 0
                print("DOCUMENTCOUNT \(documentCount)")
                // remove user instance from users collection in podID document
                self.PODS_REF.document(podID).collection("users").document(user.uid).delete()
                
                if documentCount <= 1 { // if user is last person in Pod delete Pod
                    self.PODS_REF.document(podID).delete()
                }
                
                // removes pod instance from CURRENT_USER
                self.USER_REF.document(user.uid!).collection("pods").document(podID).delete()
            }
            completion()
        }
    }
    
    // used to invite another user to pod
    func sendPodRequest(podID: String, user: User) {
        // adds Pod info to userID's receivedPodsRequests collection
        USER_REF.document(user.uid).collection("receivedPodsRequests").document(podID).setData([
            "invitedBy": CURRENT_USER_USERNAME
        ])
        
        // adds user to sentInvites collection for podID document
        PODS_REF.document(podID).collection("sentInvites").document(user.uid).setData([
            "username": user.username!
        ])
    }
    
    func rejectPodRequest(podID: String, userID: String) {
        // removes userID from collection sentInvites from podID document
        PODS_REF.document(podID).collection("sentInvites").document(userID).delete()
        
        // deletes invite from user's pod invites
        CURRENT_USER_RECEIVED_PODS_REQUEST_REF.document(podID).delete()
    }
    
    func acceptPodRequest(pod: Pods, userID: String) {
        // removes invite instance from CURRENT_USER and userID
        // doesn't actually "reject" invite used more as a cleanup in this instance
        rejectPodRequest(podID: pod.podID, userID: userID)
        
        addUserToPod(podID: pod.podID)
        
        // begin monitoring in the background as soon as user accepts pod request
        ScreenTimeViewModel().beginMonitoring(pod: pod)
    }
    
    // MARK: Fetching pods from firestore ----------------------------
    
    func listenUsersPods(completion: @escaping () -> Void) {
        
        // listen to current user's collection of pod id docs
        CURRENT_USER_PODS_REF.addSnapshotListener { querySnapshot, error in
            guard let documents = querySnapshot?.documents else {
                print("listenUsersPods(): Error fetching documents")
                return
            }
            
            for document in documents {
                let podID = document.documentID
                
                // doesn't "relisten to pre-existing pods"
                if self.allPodsList.contains(where: { $0.podID == podID }) { continue }
                
                // add a listener for every pod id in current user's pods collection
                self.listenPod(podID: document.documentID) { newPod in
                    if let index = self.allPodsList.firstIndex(where: { $0.podID == newPod.podID }) {
                        self.allPodsList[index] = newPod    // so we don't add duplicate pods
                        if self.currentPod.podID == newPod.podID {
                            self.currentPod = newPod    // updates current pod
                        }
                    } else {
                        self.allPodsList.append(newPod)
                        
                        // add observer for threshold reahced
                        DarwinNotificationCenter.shared.addObserver(
                            DarwinNotificationCenter.shared,
                            for: DarwinNotification.Name("\(newPod.podID!).threshold")
                        ) { notification in
                            FirestoreFunctions.system.thresholdReached(pod: newPod)
                        }
                        
                        // add observer for intervalStarted
                        DarwinNotificationCenter.shared.addObserver(
                            DarwinNotificationCenter.shared,
                            for: DarwinNotification.Name("\(newPod.podID!).intervalStarted")
                        ) { notification in
                            FirestoreFunctions.system.intervalStarted(pod: newPod)
                        }
                    }
                    completion()
                }
            }
        }
    }
    
    func listenPod(podID: String, completion: @escaping (Pods) -> Void) {
        PODS_REF.document(podID).addSnapshotListener { documentSnapshot, error in
            guard let document = documentSnapshot, document.exists else {
                print("listenPods(): error fetching pod document for podID: \(podID)")
                return
            }
            
            if let data = document.data(),
               let title = data["title"] as? String,
               let podType = groupType(rawValue: (data["podType"] as? String) ?? "Screen Time"),
               let currentStrikes = data["currentStrikes"] as? Int,
               let totalStrikes = data["totalStrikes"] as? Int,
               let goal = data["goal"] as? Int,
               let timeframe = data["timeframe"] as? Double,
               let started = data["started"] as? Bool,
               let failedDays = data["failedDays"] as? [Int],
               let currentDay = data["currentDay"] as? Int {
                let pod = Pods(podID: podID, title: title, podType: podType, totalStrikes: totalStrikes, currentStrikes: currentStrikes, goal: goal, timeframe: timeframe, started: started, failedDays: failedDays, currentDay: currentDay)
                completion(pod)
            }
        }
    }
}
